{
  "manifest": {
    "name": "ts-mixer",
    "version": "6.0.3",
    "description": "A very small TypeScript library that provides tolerable Mixin functionality.",
    "main": "dist/cjs/index.js",
    "module": "dist/esm/index.js",
    "browser": "dist/esm/index.js",
    "unpkg": "dist/esm/index.min.js",
    "types": "dist/types/index.d.ts",
    "files": [
      "dist"
    ],
    "scripts": {
      "prebuild": "yarn clean",
      "build": "rollup -c && tsc",
      "clean": "rimraf dist",
      "lint": "eslint src/**/*.ts",
      "test": "nyc mocha",
      "codegen": "node ./codegen.js",
      "release": "standard-version"
    },
    "devDependencies": {
      "@commitlint/cli": "^12.1.4",
      "@commitlint/config-conventional": "^12.1.4",
      "@rollup/plugin-typescript": "^8.2.1",
      "@types/chai": "^4.2.19",
      "@types/mocha": "^8.2.2",
      "@types/node": "^15.12.4",
      "@types/sinon": "^10.0.2",
      "@typescript-eslint/parser": "^4.27.0",
      "chai": "^4.3.4",
      "class-validator": "^0.13.1",
      "coveralls": "^3.1.0",
      "eslint": "^7.29.0",
      "husky": "^4.2.5",
      "js-yaml": "^4.1.0",
      "mocha": "^9.0.1",
      "nyc": "14.1.1",
      "rimraf": "^3.0.2",
      "rollup": "^2.52.1",
      "rollup-plugin-terser": "^7.0.2",
      "sinon": "^11.1.1",
      "standard-version": "^9.3.0",
      "ts-node": "^10.0.0",
      "tslib": "^2.3.0",
      "typescript": "^4.3.4",
      "yarn-add-no-save": "^1.0.3"
    },
    "homepage": "https://github.com/tannerntannern/ts-mixer#readme",
    "repository": {
      "type": "git",
      "url": "git+https://github.com/tannerntannern/ts-mixer.git"
    },
    "keywords": [
      "typescript",
      "mixin",
      "mixins",
      "multiple inheritance",
      "mixin classes"
    ],
    "author": {
      "name": "Tanner Nielsen"
    },
    "license": "MIT",
    "_registry": "npm",
    "_loc": "/home/runner/VC-Bot/.cache/yarn/v6/npm-ts-mixer-6.0.3-integrity/node_modules/ts-mixer/package.json",
    "readmeFilename": "README.md",
    "readme": "# ts-mixer\n[version-badge]: https://badgen.net/npm/v/ts-mixer\n[version-link]: https://npmjs.com/package/ts-mixer\n[build-link]: https://github.com/tannerntannern/ts-mixer/actions\n[ts-versions]: https://badgen.net/badge/icon/4.2,4.4,4.6,4.8?icon=typescript&label&list=|\n[node-versions]: https://badgen.net/badge/node/12%2C14%2C16%2C18/blue/?list=|\n[![npm version][version-badge]][version-link]\n[![TS Versions][ts-versions]][build-link]\n[![Node.js Versions][node-versions]][build-link]\n[![Minified Size](https://badgen.net/bundlephobia/min/ts-mixer)](https://bundlephobia.com/result?p=ts-mixer)\n[![Conventional Commits](https://badgen.net/badge/conventional%20commits/1.0.0/yellow)](https://conventionalcommits.org)\n\n## Overview\n`ts-mixer` brings mixins to TypeScript.  \"Mixins\" to `ts-mixer` are just classes, so you already know how to write them, and you can probably mix classes from your favorite library without trouble.\n\nThe mixin problem is more nuanced than it appears.  I've seen countless code snippets that work for certain situations, but fail in others.  `ts-mixer` tries to take the best from all these solutions while accounting for the situations you might not have considered.\n\n[Quick start guide](#quick-start)\n\n### Features\n* mixes plain classes\n* mixes classes that extend other classes\n* mixes classes that were mixed with `ts-mixer`\n* supports static properties\n* supports protected/private properties (the popular function-that-returns-a-class solution does not)\n* mixes abstract classes (requires TypeScript >= 4.2)\n* mixes generic classes (with caveats [[1](#caveats)])\n* supports class, method, and property decorators (with caveats [[2, 5](#caveats)])\n* mostly supports the complexity presented by constructor functions (with caveats [[3](#caveats)])\n* comes with an `instanceof`-like replacement (with caveats [[4, 5](#caveats)])\n* [multiple mixing strategies](#settings) (ES6 proxies vs hard copy)\n\n### Caveats\n1. Mixing generic classes requires a more cumbersome notation, but it's still possible.  See [mixing generic classes](#mixing-generic-classes) below.\n2. Using decorators in mixed classes also requires a more cumbersome notation.  See [mixing with decorators](#mixing-with-decorators) below.\n3. ES6 made it impossible to use `.apply(...)` on class constructors (or any means of calling them without `new`), which makes it impossible for `ts-mixer` to pass the proper `this` to your constructors.  This may or may not be an issue for your code, but there are options to work around it.  See [dealing with constructors](#dealing-with-constructors) below.\n4. `ts-mixer` does not support `instanceof` for mixins, but it does offer a replacement.  See the [hasMixin function](#hasmixin) for more details.\n5. Certain features (specifically, `@decorator` and `hasMixin`) make use of ES6 `Map`s, which means you must either use ES6+ or polyfill `Map` to use them.  If you don't need these features, you should be fine without.\n\n## Quick Start\n### Installation\n```\n$ npm install ts-mixer\n```\n\nor if you prefer [Yarn](https://yarnpkg.com):\n\n```\n$ yarn add ts-mixer\n```\n\n### Basic Example\n```typescript\nimport { Mixin } from 'ts-mixer';\n\nclass Foo {\n    protected makeFoo() {\n        return 'foo';\n    }\n}\n\nclass Bar {\n    protected makeBar() {\n        return 'bar';\n    }\n}\n\nclass FooBar extends Mixin(Foo, Bar) {\n    public makeFooBar() {\n        return this.makeFoo() + this.makeBar();\n    }\n}\n\nconst fooBar = new FooBar();\n\nconsole.log(fooBar.makeFooBar());  // \"foobar\"\n```\n\n## Special Cases\n### Mixing Generic Classes\nFrustratingly, it is _impossible_ for generic parameters to be referenced in base class expressions.  No matter what, you will eventually run into `Base class expressions cannot reference class type parameters.`\n\nThe way to get around this is to leverage [declaration merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html), and a slightly different mixing function from ts-mixer: `mix`.  It works exactly like `Mixin`, except it's a decorator, which means it doesn't affect the type information of the class being decorated.  See it in action below:\n\n```typescript\nimport { mix } from 'ts-mixer';\n\nclass Foo<T> {\n    public fooMethod(input: T): T {\n        return input;\n    }\n}\n\nclass Bar<T> {\n    public barMethod(input: T): T {\n        return input;\n    }\n}\n\ninterface FooBar<T1, T2> extends Foo<T1>, Bar<T2> { }\n@mix(Foo, Bar)\nclass FooBar<T1, T2> {\n    public fooBarMethod(input1: T1, input2: T2) {\n        return [this.fooMethod(input1), this.barMethod(input2)];\n    }\n}\n```\n\nKey takeaways from this example:\n* `interface FooBar<T1, T2> extends Foo<T1>, Bar<T2> { }` makes sure `FooBar` has the typing we want, thanks to declaration merging\n* `@mix(Foo, Bar)` wires things up \"on the JavaScript side\", since the interface declaration has nothing to do with runtime behavior.\n* The reason we have to use the `mix` decorator is that the typing produced by `Mixin(Foo, Bar)` would conflict with the typing of the interface.  `mix` has no effect \"on the TypeScript side,\" thus avoiding type conflicts.\n\n### Mixing with Decorators\nPopular libraries such as [class-validator](https://github.com/typestack/class-validator) and [TypeORM](https://github.com/typeorm/typeorm) use decorators to add functionality.  Unfortunately, `ts-mixer` has no way of knowing what these libraries do with the decorators behind the scenes.  So if you want these decorators to be \"inherited\" with classes you plan to mix, you first have to wrap them with a special `decorate` function exported by `ts-mixer`.  Here's an example using `class-validator`:\n\n```typescript\nimport { IsBoolean, IsIn, validate } from 'class-validator';\nimport { Mixin, decorate } from 'ts-mixer';\n\nclass Disposable {\n    @decorate(IsBoolean())  // instead of @IsBoolean()\n    isDisposed: boolean = false;\n}\n\nclass Statusable {\n    @decorate(IsIn(['red', 'green']))  // instead of @IsIn(['red', 'green'])\n    status: string = 'green';\n}\n\nclass ExtendedObject extends Mixin(Disposable, Statusable) {}\n\nconst extendedObject = new ExtendedObject();\nextendedObject.status = 'blue';\n\nvalidate(extendedObject).then(errors => {\n    console.log(errors);\n});\n```\n\n### Dealing with Constructors\nAs mentioned in the [caveats section](#caveats), ES6 disallowed calling constructor functions without `new`.  This means that the only way for `ts-mixer` to mix instance properties is to instantiate each base class separately, then copy the instance properties into a common object.  The consequence of this is that constructors mixed by `ts-mixer` will _not_ receive the proper `this`.\n\n**This very well may not be an issue for you!**  It only means that your constructors need to be \"mostly pure\" in terms of how they handle `this`.  Specifically, your constructors cannot produce [side effects](https://en.wikipedia.org/wiki/Side_effect_%28computer_science%29) involving `this`, _other than adding properties to `this`_ (the most common side effect in JavaScript constructors).\n\nIf you simply cannot eliminate `this` side effects from your constructor, there is a workaround available:  `ts-mixer` will automatically forward constructor parameters to a predesignated init function (`settings.initFunction`) if it's present on the class.  Unlike constructors, functions can be called with an arbitrary `this`, so this predesignated init function _will_ have the proper `this`.  Here's a basic example:\n\n```typescript\nimport { Mixin, settings } from 'ts-mixer';\n\nsettings.initFunction = 'init';\n\nclass Person {\n    public static allPeople: Set<Person> = new Set();\n    \n    protected init() {\n        Person.allPeople.add(this);\n    }\n}\n\ntype PartyAffiliation = 'democrat' | 'republican';\n\nclass PoliticalParticipant {\n    public static democrats: Set<PoliticalParticipant> = new Set();\n    public static republicans: Set<PoliticalParticipant> = new Set();\n    \n    public party: PartyAffiliation;\n    \n    // note that these same args will also be passed to init function\n    public constructor(party: PartyAffiliation) {\n        this.party = party;\n    }\n    \n    protected init(party: PartyAffiliation) {\n        if (party === 'democrat')\n            PoliticalParticipant.democrats.add(this);\n        else\n            PoliticalParticipant.republicans.add(this);\n    }\n}\n\nclass Voter extends Mixin(Person, PoliticalParticipant) {}\n\nconst v1 = new Voter('democrat');\nconst v2 = new Voter('democrat');\nconst v3 = new Voter('republican');\nconst v4 = new Voter('republican');\n```\n\nNote the above `.add(this)` statements.  These would not work as expected if they were placed in the constructor instead, since `this` is not the same between the constructor and `init`, as explained above.\n\n## Other Features\n### hasMixin\nAs mentioned above, `ts-mixer` does not support `instanceof` for mixins.  While it is possible to implement [custom `instanceof` behavior](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/hasInstance), this library does not do so because it would require modifying the source classes, which is deliberately avoided.\n\nYou can fill this missing functionality with `hasMixin(instance, mixinClass)` instead.  See the below example:\n\n```typescript\nimport { Mixin, hasMixin } from 'ts-mixer';\n\nclass Foo {}\nclass Bar {}\nclass FooBar extends Mixin(Foo, Bar) {}\n\nconst instance = new FooBar();\n\n// doesn't work with instanceof...\nconsole.log(instance instanceof FooBar)  // true\nconsole.log(instance instanceof Foo)     // false\nconsole.log(instance instanceof Bar)     // false\n\n// but everything works nicely with hasMixin!\nconsole.log(hasMixin(instance, FooBar))  // true\nconsole.log(hasMixin(instance, Foo))     // true\nconsole.log(hasMixin(instance, Bar))     // true\n```\n\n`hasMixin(instance, mixinClass)` will work anywhere that `instance instanceof mixinClass` works.  Additionally, like `instanceof`, you get the same [type narrowing benefits](https://www.typescriptlang.org/docs/handbook/advanced-types.html#instanceof-type-guards):\n\n```typescript\nif (hasMixin(instance, Foo)) {\n    // inferred type of instance is \"Foo\"\n}\n\nif (hasMixin(instance, Bar)) {\n    // inferred type of instance of \"Bar\"\n}\n```\n\n## Settings\nts-mixer has multiple strategies for mixing classes which can be configured by modifying `settings` from ts-mixer.  For example:\n\n```typescript\nimport { settings, Mixin } from 'ts-mixer';\n\nsettings.prototypeStrategy = 'proxy';\n\n// then use `Mixin` as normal...\n```\n\n### `settings.prototypeStrategy`\n* Determines how ts-mixer will mix class prototypes together\n* Possible values:\n    - `'copy'` (default) - Copies all methods from the classes being mixed into a new prototype object.  (This will include all methods up the prototype chains as well.)  This is the default for ES5 compatibility, but it has the downside of stale references.  For example, if you mix `Foo` and `Bar` to make `FooBar`, then redefine a method on `Foo`, `FooBar` will not have the latest methods from `Foo`.  If this is not a concern for you, `'copy'` is the best value for this setting.\n    - `'proxy'` - Uses an ES6 Proxy to \"soft mix\" prototypes.  Unlike `'copy'`, updates to the base classes _will_ be reflected in the mixed class, which may be desirable.  The downside is that method access is not as performant, nor is it ES5 compatible.\n\n### `settings.staticsStrategy`\n* Determines how static properties are inherited\n* Possible values:\n    - `'copy'` (default) - Simply copies all properties (minus `prototype`) from the base classes/constructor functions onto the mixed class.  Like `settings.prototypeStrategy = 'copy'`, this strategy also suffers from stale references, but shouldn't be a concern if you don't redefine static methods after mixing.\n    - `'proxy'` - Similar to `settings.prototypeStrategy`, proxy's static method access to base classes.  Has the same benefits/downsides.\n\n### `settings.initFunction`\n* If set, `ts-mixer` will automatically call the function with this name upon construction\n* Possible values:\n    - `null` (default) - disables the behavior\n    - a string - function name to call upon construction\n* Read more about why you would want this in [dealing with constructors](#dealing-with-constructors)\n\n### `settings.decoratorInheritance`\n* Determines how decorators are inherited from classes passed to `Mixin(...)`\n* Possible values:\n    - `'deep'` (default) - Deeply inherits decorators from all given classes and their ancestors\n    - `'direct'` - Only inherits decorators defined directly on the given classes\n    - `'none'` - Skips decorator inheritance\n\n# Author\nTanner Nielsen <tannerntannern@gmail.com>\n* Website - [tannernielsen.com](http://tannernielsen.com)\n* Github - [tannerntannern](https://github.com/tannerntannern)\n",
    "licenseText": "MIT License\n\nCopyright (c) 2023 Tanner Nielsen\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.npmjs.org/ts-mixer/-/ts-mixer-6.0.3.tgz",
    "type": "tarball",
    "reference": "https://registry.npmjs.org/ts-mixer/-/ts-mixer-6.0.3.tgz",
    "hash": "",
    "integrity": "sha512-k43M7uCG1AkTyxgnmI5MPwKoUvS/bRvLvUb7+Pgpdlmok8AoqmUaZxUUw8zKM5B1lqZrt41GjYgnvAi0fppqgQ==",
    "registry": "npm",
    "packageName": "ts-mixer",
    "cacheIntegrity": "sha512-k43M7uCG1AkTyxgnmI5MPwKoUvS/bRvLvUb7+Pgpdlmok8AoqmUaZxUUw8zKM5B1lqZrt41GjYgnvAi0fppqgQ== sha1-ab1Q9Ab/OdqjaYhbFsd6YZTHyuY="
  },
  "registry": "npm",
  "hash": "938dcceee086d40913cb1827988e4c3f02a852f4bf6d1bcbbd46fbf8f8297659a893c028aa651a671514c3ccca33907596a66bb78d468d8827bc08b47e9a6a81"
}